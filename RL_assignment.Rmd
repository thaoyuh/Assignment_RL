---
title: "Reinforcement Learning Group Assignment"
author: "Group ..."
date: "Februra 2024"
output:
  pdf_document:
    fig_caption: yes
header-includes:
  \usepackage{float}
  \usepackage{booktabs} % To thicken table lines
  \usepackage{unicode-math}

---

```{r, echo = T, results = 'hide', message=FALSE}
# Packes required for subsequent analysis. P_load ensures these will be installed and loaded.
if (!require("pacman")) install.packages("pacman")
pacman::p_load(dplyr,
               tidyr,
               ggplot2,
               reshape2,
               latex2exp,
               xtable,
               urca,
               lubridate
               )

# If you do not have tinytex installed, uncomment the command below for knitting the pdf
#tinytex::install_tinytex()

```

```{r, load data}
# reads in data full
dfZozo40 <- read.csv('zozo_Context_40items.csv')
dfZozo80 <- read.csv('zozo_Context_80items.csv')
```

\section*{Question d)}
```{r}
# Visualization
# Group by date and count clicks
click_proba <- dfZozo80 %>%
  group_by(date) %>%
  summarise(click_proba = mean(click))

# Create the plot
ggplot(data = click_proba, aes(x = date, y = click_proba)) +
  geom_line() +
  labs(x = "Date", y = "Click Proba", title = "Click Proba by Date")

# Group by hour and count clicks
clicks_by_hour <- dfZozo80 %>%
  group_by(hour) %>%
  summarise(click_proba = mean(click))

# Plot
ggplot(data = clicks_by_hour, aes(x = hour, y = click_proba)) +
  geom_line() +
  labs(x = "Hour of the Day", y = "Click Proba", title = "Click Proba by Hour")


# Group by hour and date, and count clicks
clicks_by_hour_date <- dfZozo80 %>%
  group_by(date, hour) %>%
  summarise(click_proba = mean(click))

# Extract only the day component from "date"
clicks_by_hour_date$date <- day(clicks_by_hour_date$date) 

# Create a new column with hour and date
clicks_by_hour_date <- clicks_by_hour_date %>%
  mutate(hour_date = paste(date, hour, sep = " "))

# Convert hour_date to factor to ensure evenly spaced x-axis
clicks_by_hour_date$hour_date <- factor(clicks_by_hour_date$hour_date, levels = unique(clicks_by_hour_date$hour_date))

# Plot click_count by hour_date
ggplot(data = clicks_by_hour_date, aes(x = hour_date, y = click_proba, group = 1)) +
  geom_line() +
  labs(x = "Hour and Date", y = "Click Proba", title = "Click Proba by Hour and Date")
```


```{r }
# Load necessary libraries
library(lubridate)

# Assuming your dataframe is named dfZozo40
# Convert timestamp column to date
dfZozo80$date <- as.Date(dfZozo80$timestamp)
dfZozo80$hour <- hour(dfZozo80$timestamp)

# Group by items per hour and item, count the proportion of 1 occurrences in the click column
result <- dfZozo80 %>%
  group_by(date,hour, item_id) %>%
  summarize(proportion_1 = mean(click == 1, na.rm = TRUE)) %>%
  ungroup() %>%
  spread(key = item_id, value = proportion_1, fill = 0)

# View the result
print(result)
```

```{r stationarity testing} 
# Load necessary libraries
library(urca)

# Initialize an empty dataframe to store test results
test_results_df <- data.frame()

# Loop over columns starting from the second column
for (i in 2:ncol(result)) {
  # Apply ADF test to the current column
  test_result <- ur.df(result[[i]], type = "none", selectlags = "AIC")
  # Extract the test statistic from the ADF test result and store in the dataframe
  test_statistic <- test_result@teststat
  critical_values <- as.numeric(test_result@cval[2])
  
  # Compare the test statistic with the critical values
  if (test_statistic > critical_values) {
    stationarity <- "No"
  } else {
    stationarity <- "Yes"
  }
  
  # Store the results in the dataframe
  test_results_df <- rbind(test_results_df, data.frame(Item = colnames(result)[i], 
                                                      Test_Statistic = test_statistic,
                                                      Stationarity = stationarity))
}

# Print the dataframe containing test results
print(test_results_df) # stationary if the value is lower than the threshold -1.95 (0.05 significance level)

# Print the dataframe containing test results
print(xtable(test_results_df), include.rownames = FALSE)

# Reformating for generating tables
split_dfs <- lapply(seq(1, nrow(test_results_df), by = 20), function(i) test_results_df[i:min(i+19, nrow(df)), ])
combined_df <- as.data.frame(split_dfs)

# Print the dataframe and generate Latex code
print(combined_df)
#print(xtable(combined_df), include.rownames = FALSE)
```
